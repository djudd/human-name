<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Name` struct in crate `human_name`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Name">

    <title>human_name::Name - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc struct">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'>Struct Name</p><div class="block items"><ul><li><a href="#fields">Fields</a></li><li><a href="#methods">Methods</a></li><li><a href="#implementations">Trait Implementations</a></li></ul></div><p class='location'><a href='index.html'>human_name</a></p><script>window.sidebarCurrent = {name: 'Name', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>human_name</a>::<wbr><a class="struct" href=''>Name</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/human_name/lib.rs.html#62-69' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Name {
    pub hash: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>,
    // some fields omitted
}</pre><div class='docblock'><p>Represents a parsed human name.</p>

<p>Guaranteed to contain (what we think is) a surname, a first initial, and
nothing more. May also contain given &amp; middle names, middle initials, and/or
a generational suffix.</p>

<p>Construct a Name using <code>parse</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">human_name</span>::<span class="ident">Name</span>;

<span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;Jane Doe&quot;</span>).<span class="ident">unwrap</span>();</pre>

<p>Once you have a Name, you may extract is components, convert it to JSON,
or compare it with another Name to see if they are consistent with representing
the same person (see docs on <code>consistent_with</code> for details).</p>
</div><h2 id='fields' class='fields'>Fields</h2><span id='structfield.hash' class="structfield">
                           <span id='hash.v' class='invisible'>
                           <code>hash: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></code>
                           </span></span><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl <a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/human_name/comparison.rs.html#12-373' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.consistent_with' class="method"><span id='consistent_with.v' class='invisible'><code>fn <a href='#method.consistent_with' class='fnname'>consistent_with</a>(&amp;self, other: &amp;<a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>Might this name represent the same person as another name?</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">human_name</span>::<span class="ident">Name</span>;

<span class="kw">let</span> <span class="ident">j_doe</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;J. Doe&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">jane_doe</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;Jane Doe&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">john_m_doe</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;John M. Doe&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">john_l_doe</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;John L. Doe&quot;</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">j_doe</span>.<span class="ident">consistent_with</span>(<span class="kw-2">&amp;</span><span class="ident">john_m_doe</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">j_doe</span>.<span class="ident">consistent_with</span>(<span class="kw-2">&amp;</span><span class="ident">john_l_doe</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">j_doe</span>.<span class="ident">consistent_with</span>(<span class="kw-2">&amp;</span><span class="ident">jane_doe</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">j_doe</span>.<span class="ident">consistent_with</span>(<span class="kw-2">&amp;</span><span class="ident">j_doe</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">john_m_doe</span>.<span class="ident">consistent_with</span>(<span class="kw-2">&amp;</span><span class="ident">john_l_doe</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">jane_doe</span>.<span class="ident">consistent_with</span>(<span class="kw-2">&amp;</span><span class="ident">john_l_doe</span>));

<span class="kw">let</span> <span class="ident">zheng_he</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;Zheng He&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">han_chars</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;鄭和&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">han_chars</span>.<span class="ident">consistent_with</span>(<span class="kw-2">&amp;</span><span class="ident">zheng_he</span>));</pre>

<h1 id='defining-consistency' class='section-header'><a href='#defining-consistency'>Defining &quot;consistency&quot;</a></h1>
<p>Requires that all known parts are consistent, which means at minimum,
the final words of the surnames match, and one ordered set of first
and middle initials is a superset of the other. If given and/or middle
names and/or suffixes are present in both names, they must match as well.</p>

<p>Transliterates everything to ASCII before comparison using the naive
algorithm of <a href="https://github.com/chowdhurya/rust-unidecode/">unidecode</a>
(which ignores context), and ignores case, accents and combining marks.</p>

<p>In the case of given and middle names, allows one name to be a prefix of
the other, without requiring the prefix end at a word boundary as we do
with surname suffix matches, and supports matching a small number of
common nicknames and nickname patterns based on the root name.</p>

<h1 id='limitations' class='section-header'><a href='#limitations'>Limitations</a></h1>
<p>There will be false positives (&quot;Jan Doe&quot; is probably not &quot;Jane Doe&quot;),
and false negatives (&quot;James Hanson&quot; might be &quot;James Hansen&quot;). And, of
course, even identical names do not necessarily represent the same person.</p>

<p>Given limited information, we err on the side of false positives. This
kind of matching will be most useful in cases where we already have
reason to believe that a single individual&#39;s name appears twice, and we
are trying to figure out exactly where, e.g. a particular author&#39;s index
in the list of authors of a co-authored paper.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/human_name/web_match.rs.html#6-240' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.matches_slug_or_localpart' class="method"><span id='matches_slug_or_localpart.v' class='invisible'><code>fn <a href='#method.matches_slug_or_localpart' class='fnname'>matches_slug_or_localpart</a>(&amp;self, string: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>Does this name appear to match a munged string such as an email
localpart or URL slug, where whitespace has been removed?</p>

<h1 id='examples-1' class='section-header'><a href='#examples-1'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">human_name</span>::<span class="ident">Name</span>;
<span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;Jane A. Doe&quot;</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">name</span>.<span class="ident">matches_slug_or_localpart</span>(<span class="string">&quot;jane.doe&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">name</span>.<span class="ident">matches_slug_or_localpart</span>(<span class="string">&quot;john.doe&quot;</span>));

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">name</span>.<span class="ident">matches_slug_or_localpart</span>(<span class="string">&quot;janedoe&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">name</span>.<span class="ident">matches_slug_or_localpart</span>(<span class="string">&quot;johndoe&quot;</span>));

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">name</span>.<span class="ident">matches_slug_or_localpart</span>(<span class="string">&quot;jad&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">name</span>.<span class="ident">matches_slug_or_localpart</span>(<span class="string">&quot;jd&quot;</span>));

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">name</span>.<span class="ident">matches_slug_or_localpart</span>(<span class="string">&quot;janed&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">name</span>.<span class="ident">matches_slug_or_localpart</span>(<span class="string">&quot;jane&quot;</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">name</span>.<span class="ident">matches_slug_or_localpart</span>(<span class="string">&quot;johnd&quot;</span>));
</pre>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/human_name/lib.rs.html#71-429' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.parse' class="method"><span id='parse.v' class='invisible'><code>fn <a href='#method.parse' class='fnname'>parse</a>(name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a>&gt;</code></span></h4>
<div class='docblock'><p>Parses a string represent a single person&#39;s full name into a canonical
representation.</p>

<h1 id='examples-2' class='section-header'><a href='#examples-2'>Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">human_name</span>::<span class="ident">Name</span>;

<span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;Jane Doe&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Doe&quot;</span>, <span class="ident">name</span>.<span class="ident">surname</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Jane&quot;</span>), <span class="ident">name</span>.<span class="ident">given_name</span>());

<span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;Doe, J&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Doe&quot;</span>, <span class="ident">name</span>.<span class="ident">surname</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">name</span>.<span class="ident">given_name</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&#39;J&#39;</span>, <span class="ident">name</span>.<span class="ident">first_initial</span>());

<span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;Dr. Juan Alberto T. Velasquez y Garcia III&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;Velasquez y Garcia&quot;</span>, <span class="ident">name</span>.<span class="ident">surname</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Juan&quot;</span>), <span class="ident">name</span>.<span class="ident">given_name</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;AT&quot;</span>), <span class="ident">name</span>.<span class="ident">middle_initials</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;III&quot;</span>), <span class="ident">name</span>.<span class="ident">suffix</span>());</pre>

<h1 id='supported-formats' class='section-header'><a href='#supported-formats'>Supported formats</a></h1>
<p>Supports a variety of formats, including prefix and postfix titles,
parenthesized nicknames, initials with and without periods, and sort
order (&quot;Doe, Jane&quot;). Makes use of heuristics based on case when
applicable (e.g., &quot;AL Doe&quot; is parsed as &quot;A. L. Doe&quot;, while &quot;Al Doe&quot; is
parsed as a given name and surname), as well as <em>small</em> sets of known
particles, conjunctions, titles, etc.</p>

<h1 id='limitations-1' class='section-header'><a href='#limitations-1'>Limitations</a></h1>
<p>Errs on the side of producing parse output rather than giving up, so
this function is <em>not</em> suitable as a way of guessing whether a given
string actually represents a name.</p>

<p>However, success requires at least an apparent surname and first initial.
Single-word names cannot be parsed (you may or may not wish to assume
they are given names).</p>

<p>Does not preserve titles (other than generational suffixes such as &quot;III&quot;)
or nicknames. Does not handle plural forms specially: &quot;Mr. &amp; Mrs. John
Doe&quot; will be parsed as &quot;John Doe&quot;, and &quot;Jane Doe, et al&quot; will be parsed
as &quot;Jane Doe&quot;.</p>

<p>Works best on Latin names - i.e., data from North or South America or
Europe. Does not understand surname-first formats without commas: &quot;Kim
Il-sung&quot; will be parsed as having the first name &quot;Kim&quot;.</p>

<p>Handles non-Latin unicode strings, but without any particular intelligence.
Attempts at least to fail nicely, such that either <code>parse</code> returns <code>None</code>,
or calling <code>display_full()</code> on the parsed result returns the input,
plus or minus whitespace.</p>

<p>Of course, <a href="http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/">there is no perfect algorithm</a>
for canonicalizing names. The goal here is to do the best we can without
large statistical models.</p>
</div><h4 id='method.first_initial' class="method"><span id='first_initial.v' class='invisible'><code>fn <a href='#method.first_initial' class='fnname'>first_initial</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.char.html">char</a></code></span></h4>
<div class='docblock'><p>First initial (always present)</p>
</div><h4 id='method.given_name' class="method"><span id='given_name.v' class='invisible'><code>fn <a href='#method.given_name' class='fnname'>given_name</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</code></span></h4>
<div class='docblock'><p>Given name as a string, if present</p>
</div><h4 id='method.goes_by_middle_name' class="method"><span id='goes_by_middle_name.v' class='invisible'><code>fn <a href='#method.goes_by_middle_name' class='fnname'>goes_by_middle_name</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>Does this person use a middle name in place of their given name (e.g., T. Boone Pickens)?</p>
</div><h4 id='method.initials' class="method"><span id='initials.v' class='invisible'><code>fn <a href='#method.initials' class='fnname'>initials</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></code></span></h4>
<div class='docblock'><p>First and middle initials as a string (always present)</p>
</div><h4 id='method.middle_names' class="method"><span id='middle_names.v' class='invisible'><code>fn <a href='#method.middle_names' class='fnname'>middle_names</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;</code></span></h4>
<div class='docblock'><p>Middle names as an array of words, if present</p>
</div><h4 id='method.middle_name' class="method"><span id='middle_name.v' class='invisible'><code>fn <a href='#method.middle_name' class='fnname'>middle_name</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/collections/borrow/enum.Cow.html" title="enum collections::borrow::Cow">Cow</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;</code></span></h4>
<div class='docblock'><p>Middle names as a string, if present</p>
</div><h4 id='method.middle_initials' class="method"><span id='middle_initials.v' class='invisible'><code>fn <a href='#method.middle_initials' class='fnname'>middle_initials</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</code></span></h4>
<div class='docblock'><p>Middle initials as a string, if present</p>
</div><h4 id='method.surnames' class="method"><span id='surnames.v' class='invisible'><code>fn <a href='#method.surnames' class='fnname'>surnames</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code></span></h4>
<div class='docblock'><p>Surname as a slice of words (always present)</p>
</div><h4 id='method.surname' class="method"><span id='surname.v' class='invisible'><code>fn <a href='#method.surname' class='fnname'>surname</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/collections/borrow/enum.Cow.html" title="enum collections::borrow::Cow">Cow</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</code></span></h4>
<div class='docblock'><p>Surname as a string (always present)</p>
</div><h4 id='method.suffix' class="method"><span id='suffix.v' class='invisible'><code>fn <a href='#method.suffix' class='fnname'>suffix</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</code></span></h4>
<div class='docblock'><p>Generational suffix, if present</p>
</div><h4 id='method.display_initial_surname' class="method"><span id='display_initial_surname.v' class='invisible'><code>fn <a href='#method.display_initial_surname' class='fnname'>display_initial_surname</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a></code></span></h4>
<div class='docblock'><p>First initial (with period) and surname.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">human_name</span>::<span class="ident">Name</span>;

<span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;JOHN ALLEN Q DE LA MACDONALD JR&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;J. de la MacDonald&quot;</span>, <span class="ident">name</span>.<span class="ident">display_initial_surname</span>());</pre>
</div><h4 id='method.display_first_last' class="method"><span id='display_first_last.v' class='invisible'><code>fn <a href='#method.display_first_last' class='fnname'>display_first_last</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a></code></span></h4>
<div class='docblock'><p>Given name and surname, if given name is known, otherwise first initial
and surname.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">human_name</span>::<span class="ident">Name</span>;

<span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;JOHN ALLEN Q DE LA MACDONALD JR&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;John de la MacDonald&quot;</span>, <span class="ident">name</span>.<span class="ident">display_first_last</span>());</pre>
</div><h4 id='method.byte_len' class="method"><span id='byte_len.v' class='invisible'><code>fn <a href='#method.byte_len' class='fnname'>byte_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span></h4>
<div class='docblock'><p>Number of bytes in the full name as UTF-8 in NFKD normal form, including
spaces and punctuation.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">human_name</span>::<span class="ident">Name</span>;

<span class="kw">let</span> <span class="ident">short_name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;John Doe&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;John Doe&quot;</span>.<span class="ident">len</span>(), <span class="ident">short_name</span>.<span class="ident">byte_len</span>());

<span class="kw">let</span> <span class="ident">long_name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;JOHN ALLEN Q DE LA MACDÖNALD JR&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;John Allen Q. de la MacDönald, Jr.&quot;</span>.<span class="ident">len</span>(), <span class="ident">long_name</span>.<span class="ident">byte_len</span>());</pre>
</div><h4 id='method.display_full' class="method"><span id='display_full.v' class='invisible'><code>fn <a href='#method.display_full' class='fnname'>display_full</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/collections/string/struct.String.html" title="struct collections::string::String">String</a></code></span></h4>
<div class='docblock'><p>The full name, or as much of it as was preserved from the input,
including given name, middle names, surname and suffix.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">human_name</span>::<span class="ident">Name</span>;

<span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;JOHN ALLEN Q DE LA MACDONALD JR&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">&quot;John Allen Q. de la MacDonald, Jr.&quot;</span>, <span class="ident">name</span>.<span class="ident">display_full</span>());</pre>
</div><h4 id='method.surname_hash' class="method"><span id='surname_hash.v' class='invisible'><code>fn <a href='#method.surname_hash' class='fnname'>surname_hash</a>&lt;H:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: &amp;mut H)</code></span></h4>
<div class='docblock'><p>Implements a hash for a name that is always identical for two names that
may be consistent according to our matching algorithm.</p>

<h3 id='warning' class='section-header'><a href='#warning'>WARNING</a></h3>
<p>This hash function is prone to collisions!</p>

<p>We can only use the last four alphabetical characters of the surname,
because that&#39;s all we&#39;re guaranteed to use in the consistency test. That
means if names are ASCII, we only have 19 bits of variability.</p>

<p>That means if you are working with a lot of names and you expect surnames
to be similar or identical, you might be better off avoiding hash-based
datastructures (or using a custom hash and matching algorithm).</p>

<p>We can&#39;t use more characters of the surname because we treat names as equal
when one surname ends with the other and the smaller is at least four
characters, to catch cases like &quot;Iria Gayo&quot; == &quot;Iria del Río Gayo&quot;.</p>

<p>We can&#39;t use the first initial because we might ignore it if someone goes
by a middle name or nickname, or due to transliteration.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="../rustc_serialize/json/trait.ToJson.html" title="trait rustc_serialize::json::ToJson">ToJson</a> for <a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/human_name/serialization.rs.html#5-43' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.to_json' class="method"><span id='to_json.v' class='invisible'><code>fn <a href='../rustc_serialize/json/trait.ToJson.html#tymethod.to_json' class='fnname'>to_json</a>(&amp;self) -&gt; <a class="enum" href="../rustc_serialize/json/enum.Json.html" title="enum rustc_serialize::json::Json">Json</a></code></span></h4>
<div class='docblock'><p>Serializes a name into parsed components.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">human_name</span>::<span class="ident">Name</span>;
<span class="kw">use</span> <span class="ident">rustc_serialize</span>::<span class="ident">json</span>::<span class="ident">ToJson</span>;

<span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">Name</span>::<span class="ident">parse</span>(<span class="string">&quot;JOHN ALLEN Q MACDONALD JR&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="string">r#&quot;{&quot;first_initial&quot;:&quot;J&quot;,&quot;given_name&quot;:&quot;John&quot;,&quot;middle_initials&quot;:&quot;AQ&quot;,&quot;middle_names&quot;:&quot;Allen&quot;,&quot;suffix&quot;:&quot;Jr.&quot;,&quot;surname&quot;:&quot;MacDonald&quot;}&quot;#</span>,
  <span class="ident">name</span>.<span class="ident">to_json</span>().<span class="ident">to_string</span>()
);</pre>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/human_name/eq_hash.rs.html#13' title='goto source code'>[src]</a></span></h3>
<div class='docblock'><p>Might this name represent the same person as another name?</p>

<h3 id='warning-1' class='section-header'><a href='#warning-1'>WARNING</a></h3>
<p>This is technically an invalid implementation of PartialEq because it is
not transitive - &quot;J. Doe&quot; == &quot;Jane Doe&quot;, and &quot;J. Doe&quot; == &quot;John Doe&quot;, but
&quot;Jane Doe&quot; != &quot;John Doe&quot;. (It is, however, symmetric and reflexive.)</p>

<p>Use with caution! See <code>consistent_with</code> docs for details.</p>
</div><div class='impl-items'></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/human_name/eq_hash.rs.html#14-18' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.eq' class="method"><span id='eq.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span></h4>
<div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne' class="method"><span id='ne.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/human_name/eq_hash.rs.html#29-33' title='goto source code'>[src]</a></span></h3>
<div class='docblock'><p>Implements a hash for a name that is always identical for two names that
may be equal.</p>

<h3 id='warning-2' class='section-header'><a href='#warning-2'>WARNING</a></h3>
<p>This hash function is prone to collisions!</p>

<p>See docs on <code>surname_hash</code> for details.</p>
</div><div class='impl-items'><h4 id='method.hash' class="method"><span id='hash.v-1' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;H:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: &amp;mut H)</code></span></h4>
<div class='docblock'><p>Feeds this value into the given [<code>Hasher</code>]. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div><h4 id='method.hash_slice' class="method"><span id='hash_slice.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[Self]</a>, state: &amp;mut H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></code><div class='since' title='Stable since Rust version 1.3.0'>1.3.0</div></span></h4>
<div class='docblock'><p>Feeds a slice of this type into the given [<code>Hasher</code>]. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/human_name/lib.rs.html#61' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.clone' class="method"><span id='clone.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a></code></span></h4>
<div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method"><span id='clone_from.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></span></h4>
<div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../human_name/struct.Name.html" title="struct human_name::Name">Name</a></code></span><span class='out-of-band'><div class='ghost'></div><a class='srclink' href='../src/human_name/lib.rs.html#61' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.fmt' class="method"><span id='fmt.v' class='invisible'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, __arg_0: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code></span></h4>
<div class='docblock'><p>Formats the value using the given formatter.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "human_name";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>